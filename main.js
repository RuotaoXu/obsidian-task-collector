/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => main_default
});

// src/taskcollector-Plugin.ts
var import_obsidian3 = __toModule(require("obsidian"));

// src/taskcollector-TaskCollector.ts
var import_obsidian = __toModule(require("obsidian"));
var TaskCollector = class {
  constructor(app) {
    this.app = app;
    this.completedOrCanceled = new RegExp(/^(\s*- \[)[xX-](\] .*)$/);
  }
  updateSettings(settings) {
    this.settings = settings;
    let momentMatchString = null;
    if (settings.appendDateFormat) {
      const literals = [];
      let foundLiteral = false;
      let literal = "";
      momentMatchString = "";
      for (const c of settings.appendDateFormat) {
        if (c == "[") {
          foundLiteral = true;
        } else if (foundLiteral) {
          if (c == "]") {
            const i = literals.push(literal);
            literal = "";
            momentMatchString += `%$${i - 1}$%`;
            foundLiteral = false;
          } else {
            literal += c;
          }
        } else {
          momentMatchString += c;
        }
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i = 0; i < literals.length; i++) {
          momentMatchString = momentMatchString.replace(`%$${i}$%`, literals[i]);
        }
      }
      momentMatchString = momentMatchString.replace(/\(/, "\\(").replace(/\)/, "\\)");
    }
    const rightClickTaskMenu = this.settings.rightClickComplete || this.settings.rightClickMove;
    this.initSettings = {
      removeRegExp: this.tryCreateRemoveRegex(this.settings.removeExpression),
      resetRegExp: this.tryCreateResetRegex(momentMatchString),
      incompleteTaskRegExp: this.tryCreateIncompleteRegex(this.settings.incompleteTaskValues),
      rightClickTaskMenu
    };
    console.log("loaded TC settings: %o, %o", this.settings, this.initSettings);
  }
  tryCreateRemoveRegex(param) {
    return param ? new RegExp(param, "g") : null;
  }
  tryCreateResetRegex(param) {
    return param ? new RegExp(param + "$") : null;
  }
  tryCreateIncompleteRegex(param) {
    return param ? new RegExp(`^(\\s*- \\[)[${param}](\\] .*)$`) : new RegExp(/^(\s*- \[) (\] .*)$/);
  }
  updateTaskLine(lineText, mark) {
    let marked = lineText.replace(this.initSettings.incompleteTaskRegExp, "$1" + mark + "$2");
    if (this.initSettings.removeRegExp) {
      marked = marked.replace(this.initSettings.removeRegExp, "");
    }
    if (this.settings.appendDateFormat) {
      if (!marked.endsWith(" ")) {
        marked += " ";
      }
      marked += (0, import_obsidian.moment)().format(this.settings.appendDateFormat);
    }
    return marked;
  }
  markTaskOnLine(editor, mark, i) {
    const lineText = editor.getLine(i);
    const incompleteTask = this.initSettings.incompleteTaskRegExp.exec(lineText);
    if (incompleteTask) {
      const marked = this.updateTaskLine(lineText, mark);
      editor.setLine(i, marked);
    }
  }
  markTaskOnCurrentLine(editor, mark) {
    if (editor.somethingSelected()) {
      const cursorStart = editor.getCursor("from");
      const cursorEnd = editor.getCursor("to");
      for (let i = cursorStart.line; i <= cursorEnd.line; i++) {
        this.markTaskOnLine(editor, mark, i);
      }
      editor.setSelection(cursorStart, {
        line: cursorEnd.line,
        ch: editor.getLine(cursorEnd.line).length
      });
    } else {
      const anchor = editor.getCursor("from");
      this.markTaskOnLine(editor, mark, anchor.line);
    }
  }
  markAllTasks(editor, mark) {
    const source = editor.getValue();
    const lines = source.split("\n");
    const result = [];
    for (const line of lines) {
      if (this.initSettings.incompleteTaskRegExp.exec(line)) {
        result.push(this.updateTaskLine(line, mark));
      } else {
        result.push(line);
      }
    }
    editor.setValue(result.join("\n"));
  }
  resetTaskLine(lineText) {
    let marked = lineText.replace(this.completedOrCanceled, "$1 $2");
    if (this.initSettings.resetRegExp) {
      marked = marked.replace(this.initSettings.resetRegExp, "");
    }
    return marked;
  }
  resetTaskOnLine(editor, i) {
    const lineText = editor.getLine(i);
    if (this.completedOrCanceled.exec(lineText)) {
      const marked = this.resetTaskLine(lineText);
      editor.setLine(i, marked);
    }
  }
  resetTaskOnCurrentLine(editor) {
    if (editor.somethingSelected()) {
      const cursorStart = editor.getCursor("from");
      const cursorEnd = editor.getCursor("to");
      for (let i = cursorStart.line; i <= cursorEnd.line; i++) {
        this.resetTaskOnLine(editor, i);
      }
      editor.setSelection(cursorStart, {
        line: cursorEnd.line,
        ch: editor.getLine(cursorEnd.line).length
      });
    } else {
      const anchor = editor.getCursor("from");
      this.resetTaskOnLine(editor, anchor.line);
    }
  }
  resetAllTasks(editor) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const source = editor.getValue();
    const lines = source.split("\n");
    const result = [];
    let inCompletedSection = false;
    for (const line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
        }
        result.push(line);
      } else if (line.trim() === LOG_HEADING) {
        inCompletedSection = true;
        result.push(line);
      } else if (this.completedOrCanceled.exec(line)) {
        result.push(this.resetTaskLine(line));
      } else {
        result.push(line);
      }
    }
    editor.setValue(result.join("\n"));
  }
  moveCompletedTasksInFile(editor) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const source = editor.getValue();
    const lines = source.split("\n");
    /*if (!source.contains(LOG_HEADING)) {
      if (lines[lines.length - 1].trim() !== "") {
        lines.push("");
      }
      lines.push(LOG_HEADING);
    }*/
    const remaining = [];
    const completedSection = [];
    const newTasks = [];
    let inCompletedSection = false;
    let inTask = false;
    let completedItemsIndex = lines.length;
	let start = false
    for (const line of lines) {
	  //if (!start && line.match("Todo")){
	  if (!start && line.match(/#.*(todo|Ongoing|Today)/i)){
		  start = true;
		  remaining.push(line);
		  continue;
	  }  
	  if (!start){
		remaining.push(line);
		continue;  
	  }		  
      if (inCompletedSection) {
        /*if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
          remaining.push(line);
        } else {
          completedSection.push(line);
        }*/
		completedSection.push(line);
	  } else if (remaining.length>0 && remaining[remaining.length-1]==="---" && line.startsWith("## ")) {
        inCompletedSection = true;
		const dateMatch = line.match(/(\d*-)?\d\d-\d\d[^~]*$/);
        completedItemsIndex = remaining.push("## "+dateMatch[0]+"~"+(0, import_obsidian.moment)().format(this.settings.appendDateFormat));
		completedSection.push(line);
        remaining.push("%%%COMPLETED_ITEMS_GO_HERE%%%");
      } else {
        const taskMatch = line.match(/^(-) \[(.)\]/);
        if (this.isCompletedTask(taskMatch)) {
          inTask = true;
          newTasks.push(line);
//        } else if (inTask && !taskMatch && line.match(/^( {2,}|\t)/)) {
		} else if (inTask && line.match(/^( {2,}|\t)/)) {
          newTasks.push(line);
        } else if (line.match(/^###/)) {
		  if(newTasks.length>0 && newTasks[newTasks.length-1].match(/^###/)){
			newTasks.pop();
		  }
          newTasks.push(line);
		  remaining.push(line);
		} else {
          inTask = false;
          remaining.push(line);
        }
      }
    }
	if(!inCompletedSection){
		completedItemsIndex = remaining.push("## "+(0, import_obsidian.moment)().format(this.settings.appendDateFormat));
	}
	if(newTasks.length>0 && newTasks[newTasks.length-1].match(/^##/)){
		newTasks.pop();
	}
	newTasks.push("---");
    let result = remaining.slice(0, completedItemsIndex).concat(...newTasks).concat(...completedSection);
    if (completedItemsIndex < remaining.length - 1) {
      result = result.concat(remaining.slice(completedItemsIndex + 1));
    }
    editor.setValue(result.join("\n"));
  }
  isCompletedTask(taskMatch) {
    if (taskMatch) {
      return taskMatch[2] === "x" || taskMatch[2] === "X" || this.settings.supportCanceledTasks && taskMatch[2] == "-";
    }
    return false;
  }
};

// src/taskcollector-Settings.ts
var DEFAULT_SETTINGS = {
  completedAreaHeader: "## Log",
  removeExpression: "",
  appendDateFormat: "",
  incompleteTaskValues: "",
  supportCanceledTasks: false,
  rightClickComplete: false,
  rightClickMove: false,
  rightClickReset: false,
  rightClickToggleAll: false
};

// src/taskcollector-SettingsTab.ts
var import_obsidian2 = __toModule(require("obsidian"));
var TaskCollectorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, taskCollector) {
    super(app, plugin);
    this.plugin = plugin;
    this.taskCollector = taskCollector;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const tempSettings = Object.assign(this.taskCollector.settings);
    console.log("Displaying task collector settings: %o ==> %o", this.taskCollector.settings, tempSettings);
    new import_obsidian2.Setting(containerEl).setName("Support canceled tasks").setDesc("Use a - to indicate a canceled tasks. Canceled tasks are processed in the same way as completed tasks using options below.").addToggle((toggle) => toggle.setValue(tempSettings.supportCanceledTasks).onChange((value) => __async(this, null, function* () {
      tempSettings.supportCanceledTasks = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Completing tasks" });
    new import_obsidian2.Setting(containerEl).setName("Append date to completed task").setDesc("If non-empty, append today's date in the given moment.js string format to the end of the task text.").addMomentFormat((momentFormat) => momentFormat.setPlaceholder("YYYY-MM-DD").setValue(tempSettings.appendDateFormat).onChange((value) => __async(this, null, function* () {
      try {
        (0, import_obsidian2.moment)().format(value);
        tempSettings.appendDateFormat = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      } catch (e) {
        console.log(`Error parsing specified date format: ${value}`);
      }
    })));
    new import_obsidian2.Setting(containerEl).setName("Remove text in completed task").setDesc("Text matching this regular expression should be removed from the task text. Be careful! Test your expression separately. The global flag, 'g' is used for a per-line match.").addText((text) => text.setPlaceholder(" #(todo|task)").setValue(tempSettings.removeExpression).onChange((value) => __async(this, null, function* () {
      try {
        this.taskCollector.tryCreateRemoveRegex(value);
        tempSettings.removeExpression = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      } catch (e) {
        console.log(`Error parsing regular expression for text replacement: ${value}`);
      }
    })));
    new import_obsidian2.Setting(containerEl).setName("Incomplete task indicators").setDesc("Specify the set of single characters (a space by default) that indicate incomplete tasks.").addText((text) => text.setPlaceholder("> !?").setValue(tempSettings.incompleteTaskValues).onChange((value) => __async(this, null, function* () {
      if (value.contains("x") || value.contains("X")) {
        console.log(`Set of characters should not contain the marker for completed tasks: ${value}`);
      } else if (tempSettings.supportCanceledTasks && value.contains("-")) {
        console.log(`Set of characters should not contain the marker for canceled tasks: ${value}`);
      } else {
        tempSettings.incompleteTaskValues = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }
    })));
    containerEl.createEl("h2", { text: "Moving completed tasks" });
    new import_obsidian2.Setting(containerEl).setName("Completed area header").setDesc(`Completed (or canceled) items will be inserted under the specified header (most recent at the top). When scanning the document for completed/canceled tasks, the contents from this configured header to the next heading or separator (---) will be ignored. This heading will be created if the command is invoked and the heading does not exist. The default heading is '${DEFAULT_SETTINGS.completedAreaHeader}'.`).addText((text) => text.setPlaceholder("## Log").setValue(tempSettings.completedAreaHeader).onChange((value) => __async(this, null, function* () {
      tempSettings.completedAreaHeader = value.trim();
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    containerEl.createEl("h2", { text: "Right-click Menu items" });
    new import_obsidian2.Setting(containerEl).setName("Add menu item for completing a task").setDesc("Add an item to the right-click menu in edit mode to *mark the task on the current line (or tasks within the current selection)* complete. If canceled items are supported, an additional menu item will be added to mark selected tasks as canceled.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickComplete).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickComplete = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName("Add menu items for completing all tasks").setDesc("Add an item to the right-click menu in edit mode to *mark all tasks* in the current document complete.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickToggleAll).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickToggleAll = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName("Add menu item for moving all completed tasks").setDesc("Add an item to the right-click menu in edit mode to *move all completed (or canceled) tasks*.").addToggle((toggle) => toggle.setValue(tempSettings.rightClickMove).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickMove = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian2.Setting(containerEl).setName("Include menu items for resetting tasks").setDesc("Include menu items for resetting tasks (e.g. complete, cancel, and reset individual/selected tasks; complete/reset all tasks)").addToggle((toggle) => toggle.setValue(tempSettings.rightClickReset).onChange((value) => __async(this, null, function* () {
      tempSettings.rightClickReset = value;
      this.taskCollector.updateSettings(tempSettings);
      yield this.plugin.saveSettings();
    })));
  }
};

// src/taskcollector-Plugin.ts
var TaskCollectorPlugin = class extends import_obsidian3.Plugin {
  onload() {
    return __async(this, null, function* () {
      console.log("loading Task Collector (TC): %o", this.app);
      this.taskCollector = new TaskCollector(this.app);
      this.addSettingTab(new TaskCollectorSettingsTab(this.app, this, this.taskCollector));
      yield this.loadSettings();
      (0, import_obsidian3.addIcon)("tc-complete-item", '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm10.03 4.97a.75.75 0 0 1 .011 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.75.75 0 0 1 1.08-.022z"/></svg>');
      (0, import_obsidian3.addIcon)("tc-cancel-item", '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-dash-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm2.5 7.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1z"/></svg>');
      (0, import_obsidian3.addIcon)("tc-reset-item", '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-square-fill" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg>');
      (0, import_obsidian3.addIcon)("tc-complete-all-items", '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/><g transform="translate(.49737 -.0026315)" fill="currentColor"><path d="m3.6171 13.149a.5.5 0 01-.708 0l-1-1a.50063.50063 0 01.708-.708l.646.647 1.646-1.647a.50063.50063 0 01.708.708z"/><path d="m3.6171 5.6181a.5.5 0 01-.708 0l-1-1a.50063.50063 0 11.708-.708l.646.647 1.646-1.647a.50063.50063 0 11.708.708z"/></g></svg>');
      (0, import_obsidian3.addIcon)("tc-clear-all-items", '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/></svg>');
      (0, import_obsidian3.addIcon)("tc-move-all-checked-items", '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-save-fill" viewBox="0 0 16 16">  <path d="M8.5 1.5A1.5 1.5 0 0 1 10 0h4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h6c-.314.418-.5.937-.5 1.5v7.793L4.854 6.646a.5.5 0 1 0-.708.708l3.5 3.5a.5.5 0 0 0 .708 0l3.5-3.5a.5.5 0 0 0-.708-.708L8.5 9.293V1.5z"/></svg>');
      const completeTaskCommand = {
        id: "task-collector-mark-done",
        name: "Complete item",
        icon: "tc-complete-item",
        editorCallback: (editor, view) => {
          this.taskCollector.markTaskOnCurrentLine(editor, "x");
        }
      };
      const cancelTaskCommand = {
        id: "task-collector-mark-canceled",
        name: "Cancel item",
        icon: "tc-cancel-item",
        editorCallback: (editor, view) => {
          this.taskCollector.markTaskOnCurrentLine(editor, "-");
        }
      };
      const resetTaskCommand = {
        id: "task-collector-mark-reset",
        name: "Reset item",
        icon: "tc-reset-item",
        editorCallback: (editor, view) => {
          this.taskCollector.resetTaskOnCurrentLine(editor);
        }
      };
      const completeAllTasksCommand = {
        id: "task-collector-mark-all-done",
        name: "Complete all tasks",
        icon: "tc-complete-all-items",
        editorCallback: (editor, view) => {
          this.taskCollector.markAllTasks(editor, "x");
        }
      };
      const clearAllTasksCommand = {
        id: "task-collector-clear-all-items",
        name: "Reset all completed tasks",
        icon: "tc-clear-all-items",
        editorCallback: (editor, view) => {
          this.taskCollector.resetAllTasks(editor);
        }
      };
      const moveTaskCommand = {
        id: "task-collector-move-completed-tasks",
        name: "Move all completed tasks to configured heading",
        icon: "tc-move-all-checked-items",
        editorCallback: (editor, view) => __async(this, null, function* () {
          this.taskCollector.moveCompletedTasksInFile(editor);
        })
      };
      this.addCommand(completeTaskCommand);
      if (this.taskCollector.settings.supportCanceledTasks) {
        this.addCommand(cancelTaskCommand);
      }
      this.addCommand(resetTaskCommand);
      this.addCommand(moveTaskCommand);
      this.addCommand(completeAllTasksCommand);
      this.addCommand(clearAllTasksCommand);
      if (this.taskCollector.initSettings.rightClickTaskMenu) {
        this.registerEvent(this.app.workspace.on("editor-menu", (menu) => {
          if (this.taskCollector.settings.rightClickComplete) {
            menu.addItem((item) => item.setTitle("(TC) Complete Task").setIcon(completeTaskCommand.icon).onClick(() => {
              this.app.commands.executeCommandById(completeTaskCommand.id);
            }));
            if (this.taskCollector.settings.supportCanceledTasks) {
              menu.addItem((item) => item.setTitle("(TC) Cancel Task").setIcon(cancelTaskCommand.icon).onClick(() => {
                this.app.commands.executeCommandById(cancelTaskCommand.id);
              }));
            }
            if (this.taskCollector.settings.rightClickReset) {
              menu.addItem((item) => item.setTitle("(TC) Reset Task").setIcon(resetTaskCommand.icon).onClick(() => {
                this.app.commands.executeCommandById(resetTaskCommand.id);
              }));
            }
          }
          if (this.taskCollector.settings.rightClickMove) {
            menu.addItem((item) => item.setTitle("(TC) Move completed tasks").setIcon(moveTaskCommand.icon).onClick(() => {
              this.app.commands.executeCommandById(moveTaskCommand.id);
            }));
          }
          if (this.taskCollector.settings.rightClickToggleAll) {
            menu.addItem((item) => item.setTitle("(TC) Complete All Tasks").setIcon(completeAllTasksCommand.icon).onClick(() => {
              this.app.commands.executeCommandById(completeAllTasksCommand.id);
            }));
            if (this.taskCollector.settings.rightClickReset) {
              menu.addItem((item) => item.setTitle("(TC) Reset All Tasks").setIcon(clearAllTasksCommand.icon).onClick(() => {
                this.app.commands.executeCommandById(clearAllTasksCommand.id);
              }));
            }
          }
        }));
      }
    });
  }
  onunload() {
    console.log("unloading Task Collector");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      this.taskCollector.updateSettings(settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.taskCollector.settings);
    });
  }
};

// src/main.ts
var main_default = TaskCollectorPlugin;
